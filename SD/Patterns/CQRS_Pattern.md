# CQRS (Command Query Responsibility Segregation) Pattern

## Overview

CQRS (Command Query Responsibility Segregation) is a design pattern that separates read operations (queries) from write operations (commands) in an application. This pattern uses different models to update information and read information.

## Key Concepts

### 1. Command Side
- Handles write operations (Create, Update, Delete)
- Optimized for writes and business logic
- Often uses domain models
- May include complex validation and business rules

### 2. Query Side
- Handles read operations
- Optimized for queries and data retrieval
- Uses read models or projections
- Can be denormalized for performance

### 3. Event Store
- Stores events generated by commands
- Single source of truth
- Enables event sourcing
- Provides audit trail

## Implementation Example

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from dataclasses import dataclass
from datetime import datetime
import uuid

# Command Side Models
@dataclass
class Command:
    id: str
    timestamp: datetime
    user_id: str

@dataclass
class CreateUserCommand(Command):
    username: str
    email: str
    full_name: str

@dataclass
class UpdateUserEmailCommand(Command):
    user_id: str
    new_email: str

# Event Models
@dataclass
class Event:
    id: str
    aggregate_id: str
    event_type: str
    timestamp: datetime
    data: Dict[str, Any]

# Domain Model (Write Side)
class User:
    def __init__(self, user_id: str, username: str, email: str, full_name: str):
        self.id = user_id
        self.username = username
        self.email = email
        self.full_name = full_name
        self.version = 0
        self.uncommitted_events: List[Event] = []
    
    def change_email(self, new_email: str):
        if new_email != self.email:
            self.email = new_email
            self.version += 1
            self._add_event("UserEmailChanged", {"new_email": new_email})
    
    def _add_event(self, event_type: str, data: Dict[str, Any]):
        event = Event(
            id=str(uuid.uuid4()),
            aggregate_id=self.id,
            event_type=event_type,
            timestamp=datetime.now(),
            data=data
        )
        self.uncommitted_events.append(event)

# Command Handlers
class CommandHandler(ABC):
    @abstractmethod
    def handle(self, command: Command) -> None:
        pass

class CreateUserCommandHandler(CommandHandler):
    def __init__(self, user_repository, event_store):
        self.user_repository = user_repository
        self.event_store = event_store
    
    def handle(self, command: CreateUserCommand) -> None:
        # Business logic validation
        if self.user_repository.exists_by_email(command.email):
            raise ValueError("User with this email already exists")
        
        # Create domain model
        user = User(
            user_id=str(uuid.uuid4()),
            username=command.username,
            email=command.email,
            full_name=command.full_name
        )
        
        # Save to repository
        self.user_repository.save(user)
        
        # Store events
        for event in user.uncommitted_events:
            self.event_store.append(event)

# Query Side Models (Read Models)
@dataclass
class UserProjection:
    id: str
    username: str
    email: str
    full_name: str
    created_at: datetime
    last_updated: datetime

@dataclass
class UserListProjection:
    id: str
    username: str
    email: str
    status: str

# Query Handlers
class QueryHandler(ABC):
    @abstractmethod
    def handle(self, query) -> Any:
        pass

class GetUserQuery:
    def __init__(self, user_id: str):
        self.user_id = user_id

class GetUserQueryHandler(QueryHandler):
    def __init__(self, read_repository):
        self.read_repository = read_repository
    
    def handle(self, query: GetUserQuery) -> UserProjection:
        return self.read_repository.get_user_projection(query.user_id)

# Event Projectors (Update Read Models)
class UserProjector:
    def __init__(self, read_repository):
        self.read_repository = read_repository
    
    def project(self, event: Event):
        if event.event_type == "UserCreated":
            projection = UserProjection(
                id=event.aggregate_id,
                username=event.data["username"],
                email=event.data["email"],
                full_name=event.data["full_name"],
                created_at=event.timestamp,
                last_updated=event.timestamp
            )
            self.read_repository.save_user_projection(projection)
        
        elif event.event_type == "UserEmailChanged":
            projection = self.read_repository.get_user_projection(event.aggregate_id)
            projection.email = event.data["new_email"]
            projection.last_updated = event.timestamp
            self.read_repository.update_user_projection(projection)
```

## Advantages

### 1. Performance Optimization
- Separate optimization for reads and writes
- Read models can be denormalized
- Query-specific indexes and structures

### 2. Scalability
- Independent scaling of read and write sides
- Multiple read replicas
- Different databases for different concerns

### 3. Flexibility
- Different technologies for reads and writes
- Multiple read models for different use cases
- Easier to add new query requirements

### 4. Security
- Separate permissions for commands and queries
- Fine-grained access control
- Command validation and authorization

## Implementation Patterns

### 1. Synchronous CQRS
```python
class SynchronousCQRSService:
    def __init__(self, command_bus, query_bus, event_store):
        self.command_bus = command_bus
        self.query_bus = query_bus
        self.event_store = event_store
    
    def execute_command(self, command: Command):
        # Execute command
        self.command_bus.dispatch(command)
        
        # Immediately update read models
        events = self.event_store.get_uncommitted_events()
        for event in events:
            self.update_read_models(event)
    
    def execute_query(self, query):
        return self.query_bus.dispatch(query)
```

### 2. Asynchronous CQRS
```python
class AsynchronousCQRSService:
    def __init__(self, command_bus, query_bus, event_bus):
        self.command_bus = command_bus
        self.query_bus = query_bus
        self.event_bus = event_bus
    
    def execute_command(self, command: Command):
        # Execute command
        self.command_bus.dispatch(command)
        
        # Publish events asynchronously
        events = self.get_generated_events(command)
        for event in events:
            self.event_bus.publish(event)
    
    def execute_query(self, query):
        return self.query_bus.dispatch(query)
```

## Best Practices

### 1. Command Design
- Commands should be immutable
- Include all necessary data
- Use meaningful names
- Validate at boundaries

### 2. Query Design
- Design for specific use cases
- Optimize for read performance
- Consider caching strategies
- Handle eventual consistency

### 3. Event Design
- Events are facts that happened
- Use past tense naming
- Include relevant context
- Make events immutable

### 4. Read Model Management
- Keep read models simple
- Design for specific queries
- Handle projection rebuilding
- Monitor consistency lag

## When to Use CQRS

### Good Fit
- Complex domain logic
- Different read and write requirements
- High-performance read requirements
- Event sourcing systems
- Microservices architectures

### Poor Fit
- Simple CRUD applications
- Low complexity domains
- Small teams
- Tight consistency requirements

## Common Pitfalls

### 1. Over-Engineering
- Don't use CQRS for simple scenarios
- Start simple and evolve
- Consider maintenance overhead

### 2. Eventual Consistency
- Plan for consistency delays
- Educate users about eventual consistency
- Provide feedback mechanisms

### 3. Complexity
- Additional infrastructure requirements
- More complex deployment
- Increased monitoring needs

## Related Patterns

- **Event Sourcing**: Often used together with CQRS
- **Saga Pattern**: For managing distributed transactions
- **Domain-Driven Design**: Provides context for CQRS usage
- **Microservices**: CQRS fits well in microservice architectures

## Conclusion

CQRS is a powerful pattern for separating read and write concerns in complex systems. It provides flexibility, performance benefits, and scalability at the cost of increased complexity. Consider it when you have distinct read and write requirements or when building event-driven systems.
